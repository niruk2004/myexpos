Exception Handler:


Here are four events that result in generation of an exception in XSM. These events are :

a) Illegal Memory Access: Occurs when any address generated by the application lies outside its 
logical address space. This also occurs when the process tries to write into pages whose Write 
access bit is not set in the page table. Recall that the logical page number generated for a 
valid instruction should be between 0 and the value of (512 * PTLR) - 1.

b) Illegal instructions: Occurs when an application tries to execute an instruction not belonging 
to the instruction set or when an operand/data in an instruction is not legal. (Example: MOV 4 
R0, MOV IP, 4)

c) Arithmetic exception: Occurs when there is a division/modulus by zero. (Example: DIV R0, 0)
In all the above cases, the typical action is for the exception handler code is to pass control 
to other privileged mode OS routines to terminate the application and schedule other applications.

d) Page fault: This is the most significant exception handling function that must be understood 
clearly. A page fault occurs if an instruction contains an address whose logical page number is 
within the range 0 to PTLR-1 and the valid bit in the corresponding page table entry is set to to 0. 

    Page fault exception can occur either during instruction fetch or operand fetch. Suppose during 
    execution of an application, the value of IP reaches value – say 3000. The next fetch will try to 
    translate the logical address 3000 to physical address using the page table. The logical page number 
    corresponding to address 3000 is 3000 DIV 512 = 5. The machine must look up the page table entry 
    corresponding to logical page 5. If the valid bit for this entry is set to 0, the page reference 
    is invalid. In this case, the machine will raise an exception.

    The second possibility for a page fault to occur is during operand fetch. Suppose an instruction is 
    successfully fetched – say MOV R0, [5000]. To execute the instruction, the machine will try to 
    translate the logical address 5000 using page table. As in the previous case, if the page is not 
    valid, then the machine raises an exception. 

When one of this events occur, the XSM machine raises an exception and control is 
transferred to the exception handler. The exception handler code used in previous stages 
contains only halt instruction which halts the system in the case of an exception. Clearly 
it is inappropriate to halt the system (all the processes are terminated) for exception 
occured in one process. 

When the machine raises an exception, the following occurs:

1. IP is set to value 1024 and machine switches to privileged mode. Thus, the next instruction will 
be fetched from the exception handler.

2. The machine sets several CPU registers with values that describe (to the exception handler) the 
cause of the exception. These are explained below:

    a) EIP (Exception IP): The logical IP value of the unprivileged mode instruction that caused the 
    exception is stored in this register. For example, if the instruction MOV R0, [5000], fetched 
    from IP=3000 caused an exception because the logical page corresponding to address 5000 (logical 
    page 8) was invalid, the EIP will be loaded with value 3000.

    b) EPN (Exception Page Number): The contents of this register are valid only in the case of a 
    page fault exception. The logical page number that caused the page fault is stored in this 
    register. In the above example, if MOV R0, [5000] caused a page fault because logical page 8 
    was invalid, then EPN will have value 8. Note that if the instruction fetch caused a page fault 
    (say IP=3000), then EPN would have contained value 5.

    c) EC (Exception Cause): The EC register will indicate the cause of the exception – values are 
       set as below.

        (i) Page Fault: The value stored in the EC register for this exception is 0.

        (ii) Illegal instruction: The value stored in the EC register for this exception is 1.

        (iii) Illegal memory access: The value stored in the EC register for this exception is 2.

        (iv) Arithmetic exception: The value stored in the EC register for this exception is 3.

    d) EMA (Exception memory address): The value of this register is relevant only in the case of 
    illegal memory access. The illegal memory which was tried to be accessed is stored in the register. 
    Either the address referred to is outside the range 0 - 512*(PTLR-1) or a write is attempted to a 
    page which is read-only.


    For the events 1) illegal memory access (EC=2) 2) illegal instruction (EC=1) and 3) arithmetic 
    exception (EC=3), the exception handler just prints the cause of the exception. These cases occur 
    because the last instruction executed (in the currently running user process) resulted in the 
    corresponding error condition. As the OS is not reponsible for correcting these conditions, the 
    exception handler halts the process gracefully and then invokes the scheduler to run other processes.

The page fault exception (EC=0) occurs when the last instruction in the currently running application tried to either -
a) Access/modify data from a legal address within its address space, but the page was set to invalid in the page table or
b) fetch an instruction from a legal address within its address space, whose page table entry is invalid.

In either case, the exception occured not because of any error from the side of the application, but because 
the OS had not loaded the page and set the page tables. In such case, the exception handler resumes the execution 
of the process after allocating the required page(s) for the process and attaching the page(s) to the process 
(by setting page table entries appropriately). If the faulted page is a code page, the OS needs to load the 
page from the disk to the newly allocated memory. 

But why should the OS not allocate all the pages required for a process when the process is initialized by the 
Exec system call, as we were doing in the previous two stages? The reason is that this method of pre-allocation 
allows fewer concurrent processes to run than with the present strategy of "lazy allocation" to be described now. 
The strategy followed in this stage is to start executing a process with just one page of code and two pages of 
stack allocated initially. When the process, during execution, tries to access a page that was not loaded, an 
exception is generated and the execption handler will allocate the required page. If the required page is a code 
page, the page will be transferred from the disk to the allocated memory. Since pages are allocated only on 
demand, memory utilization is better (on the average) with this approach. 

Per process disk map table:
Each process has a data structure called Per-process Disk map table. The disk map table stores the disk block 
numbers corresponding to the memory pages used by the process. Each disk map table has 10 words of which one 
is for user area page, two for heap, four for code and two for stack pages. Remaining one word is unused. 
Whenever the copy of the memory page of a process is present in some disk block, that disk block number is 
stored in the per-process Disk Map Table entry corresponding to that memory page. This is done to keep track 
of the disk copy of memory pages. The SPL constant DISK_MAP_TABLE gives the starting address of the Disk Map 
Table of process with PID as 0. The disk map table for any process is obtained by adding PID*10 to DISK_MAP_TABLE.


The Get Code Page function takes as input the block number of a single code block, and loads that block into a 
memory page. Code pages are shared by the processes running the same program. The purpose of this function is to 
find out if the current code block is already in use by some other process. This is done by going through the disk 
map table entries of all the processes checking for the code block (block number provided as argument). If found, 
then the Get Code Page checks if the code block is loaded into a memory page (entry in the corresponding page table 
should be valid). If the code block is already present in some memory page, then Get Code Page function just returns 
that memory page number. If not, a new memory page is allocated by invoking the Get Free Page function of the memory 
manager module. This is followed by loading the code block into the newly allocated memory page using the Disk Load 
function of the device manager module. The Get Code Page function finally returns the memory page number.


The exception handler first switches to the kernel stack and backs up the register context as done by any other 
hardware interrupt routine. The exception handler then uses EC register to find out the cause of the exception. If 
the cause of the exception is other than page fault, exception handler should print the appropriate error message 
to notify the user about the termination of the process. As these exceptions cannot be corrected, exception handler
must terminate the process by invoking the Exit Process function of process manager module and invoke the scheduler 
to schedule other processes.


IMP:::::::
 Note that eXpOS is designed such that, page fault exception can only occur for heap and code pages. Library pages 
 are shared by all processes so they are always present in the memory. Stack pages are neccessary to run a process 
 and are accessed more frequently. So both library and stack pages for a process should be present in the memory.

 Note: When page fault occurs for one heap page, the current eXpOS design allocates two pages for the heap. This 
 can be optimized further to make the allocation lazier by allocating just one heap page and deferring allocation 
 of a second page till a page fault occurs again for the second page. However, the lazier strategy causes some 
 complications in the implementation of the Fork system call in the next stage. Here, we have chosen to keep the 
 design simple by allocating both the heap pages when only one is demanded. 


In later stages, the OS will allocate certain disk blocks to a process temporarily. This is done to swap out the 
heap/stack pages of a process when the OS finds shortage of memory space to run all the processes. If a heap/stack 
page of a process is swapped out into some disk block, the page can be released to some other process. In such 
cases, the page table entry for the swapped out page will be set to invalid, but the entry corresponding to the 
page in the disk map table will contain the disk block number to which the page has been swapped out. The disk 
free list entry for the block will be greater than zero as the block is no longer free. (It can happen that 
multiple processes share the block. The disk free list entry for the block will indicate the count of the number 
of processes sharing the disk block.) 

When the page table entries of a process are invalidated using the Free Page Table function of the process manager 
module, (either when a process exits or when the exec system call replaces the current process with a new one) 
it is necessary to ensure that any temporary disk blocks allocated to the process are also released. Hence the 
free page table function checks whether the disk map table entry of a stack/heap page contains a valid disk block 
number, and if so decrements its disk free list entry by invoking the Release Block function of the memory manager 
module.



q2:

                niranjan@niranjan-Victus:~/myexpos/xsm$ ./xsm --debug
                enter name
                linklist.xsm
                Previous instruction at IP = 22918: BRKP
                Mode: KERNEL     PID: 1
                Next instruction at IP = 22920, Page No. = 44: RET
                debug> dmt
                Heap 1 in Disk: -1      Heap 2 in Disk: -1
                Code 1 in Disk: -1      Code 2 in Disk: -1
                Code 3 in Disk: -1      Code 4 in Disk: -1
                Stack 1 in Disk: -1     Stack 2 in Disk: -1
                debug> pt
                VIRT: 0         PHY: 63         AUX: 0100
                VIRT: 1         PHY: 64         AUX: 0100
                VIRT: 2         PHY: -1         AUX: 0000
                VIRT: 3         PHY: -1         AUX: 0000
                VIRT: 4         PHY: -1         AUX: 0000
                VIRT: 5         PHY: -1         AUX: 0000
                VIRT: 6         PHY: -1         AUX: 0000
                VIRT: 7         PHY: -1         AUX: 0000
                VIRT: 8         PHY: -1         AUX: 0000
                VIRT: 9         PHY: -1         AUX: 0000
                debug> c
                Previous instruction at IP = 1024: BRKP
                Mode: KERNEL     PID: 1
                Next instruction at IP = 1026, Page No. = 2: MOV R16,28672
                debug> r
                R0: 1024        R1: 1   R2: Heapset     R3:     R4: 
                R5: Heapset     R6:     R7:     R8:     R9: 
                R10:    R11:    R12:    R13:    R14: 
                R15:    R16: 28697      R17: 16 R18:    R19: 
                P0: linklist.xsm        P1: enter name  P2:     P3: 
                BP: 4110        SP: 4110        IP: 1026        PTBR: 29716     PTLR: 10
                EIP: 82 EC: 0   EPN: 2  EMA: 
                debug> dmt
                Heap 1 in Disk: -1      Heap 2 in Disk: -1
                Code 1 in Disk: -1      Code 2 in Disk: -1
                Code 3 in Disk: -1      Code 4 in Disk: -1
                Stack 1 in Disk: -1     Stack 2 in Disk: -1
                debug> pt
                VIRT: 0         PHY: 63         AUX: 0100
                VIRT: 1         PHY: 64         AUX: 0100
                VIRT: 2         PHY: -1         AUX: 0000
                VIRT: 3         PHY: -1         AUX: 0000
                VIRT: 4         PHY: 65         AUX: 0100
                VIRT: 5         PHY: -1         AUX: 0000
                VIRT: 6         PHY: -1         AUX: 0000
                VIRT: 7         PHY: -1         AUX: 0000
                VIRT: 8         PHY: 66         AUX: 0110
                VIRT: 9         PHY: 76         AUX: 0110
                debug> c
                Previous instruction at IP = 1024: BRKP
                Mode: KERNEL     PID: 1
                Next instruction at IP = 1026, Page No. = 2: MOV R16,28672
                debug> r
                R0: 1536        R1: 1   R2: 1   R3:     R4: 
                R5: Heapset     R6:     R7:     R8:     R9: 
                R10:    R11:    R12:    R13:    R14: 
                R15:    R16: 28697      R17: 16 R18:    R19: 
                P0: linklist.xsm        P1: enter name  P2:     P3: 
                BP: 4110        SP: 4110        IP: 1026        PTBR: 29716     PTLR: 10
                EIP: 82 EC: 0   EPN: 3  EMA: 
                debug> dmt
                Heap 1 in Disk: -1      Heap 2 in Disk: -1
                Code 1 in Disk: -1      Code 2 in Disk: -1
                Code 3 in Disk: -1      Code 4 in Disk: -1
                Stack 1 in Disk: -1     Stack 2 in Disk: -1
                debug> pt
                VIRT: 0         PHY: 63         AUX: 0100
                VIRT: 1         PHY: 64         AUX: 0100
                VIRT: 2         PHY: 77         AUX: 1110
                VIRT: 3         PHY: -1         AUX: 0000
                VIRT: 4         PHY: 65         AUX: 0100
                VIRT: 5         PHY: -1         AUX: 0000
                VIRT: 6         PHY: -1         AUX: 0000
                VIRT: 7         PHY: -1         AUX: 0000
                VIRT: 8         PHY: 66         AUX: 0110
                VIRT: 9         PHY: 76         AUX: 0110
                debug> c
                enter n:
                4
                1
                2
                3
                4
                printing:
                1
                2
                3
                4
                Machine is halting.







my group number is 31!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

